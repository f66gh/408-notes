# 第二章 线性表 Linear List

线性表是相同数据类型的n个数据元素的有限序列。线性表是一种**逻辑结构**，表示元素之间一对一的相邻关系。顺序表和链表是**存储结构**。

线性表的基本操作：

| InitList(&L)          | 初始化表                                 |
| --------------------- | ---------------------------------------- |
| Length(L)             | 求表长                                   |
| LocateElement(L,e)    | 按值查找操作                             |
| GetElem(L,i)          | 按位查找操作                             |
| ListInsert(&L, i, e)  | 插入操作                                 |
| ListDelete(&L, i, &e) | 删除操作，删除第i个元素的位置，用e返回值 |
| PrintList(L)          | 输出操作                                 |
| Empty(L)              | 判空操作                                 |
| DestoryList(&L)       | 销毁操作                                 |

## 2.2 线性表的顺序表示

线性表的顺序存储又称为顺序表。他是用一组地址连续的存储单元依次存储线性表的数据元素，**从而使得逻辑上相邻的两个元素在物理位置上也相邻**。

**顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。**

顺序表的特点：

* 随机访问，在O(1)找到第i个元素
* 存储密度高
* 拓展容量不方便
* 插入删除不方便，需要移动大量元素

```cpp
#include <iostream>
using namespace std;

// 静态线性表
#define MAXSIZE 10
typedef struct{
    int data[MAXSIZE];
    int length;
}SqList_Static;

// 动态线性表
typedef struct{
    int *data;
    int MaxSize;
    int length;
}SqList_Dynamic;

//初始化一个顺序表
void InitList(SqList_Static &L){
    for(int i = 0; i < MAXSIZE; i++){
        L.data[i] = 0;
    }
    L.length = 0;
}

void InitList_Dynamic(SqList_Dynamic &L, int MaxSize){
    L.MaxSize = MaxSize;
    L.data = new int [MaxSize];
    L.length = 0;
}

// 增加动态线性表的长度
void IncreaseSize(SqList_Dynamic &L, int len){
    int *p = L.data; //指针指向原数组
    L.data = new int [L.MaxSize + len]; // 顺序表更改存储空间
    for (int i = 0; i < L.length ; i++){
        L.data[i] = p[i]; // 将数据拷贝到新空间
    }
    L.MaxSize += len;
    delete p; // 释放原空间
    return;
}

int main (){
    SqList_Dynamic L;
    int MaxSize = 10;
    InitList_Dynamic(L, MaxSize);
    IncreaseSize(L, 10);

    cout << L.length << endl;

    return 0;
}
```

## 2.3 顺序表的插入和删除

**插入**

时间复杂度最好O(1)，最差O(n)，平均情况O（n）

设元素插入到每一个位置的概率都相同，p = 1/(n+1)，平均时间复杂度= np + (n-1)p + ... + p = n(n+1)/2  * 1/(n+1) = n/2 = O(n)

**删除**

时间复杂度最好O(1)，最差O(n)，平均O(n)

```cpp
#include<iostream>
#define MaxSize 10
using namespace std;

typedef struct{
    int data[MaxSize];
    int length = 0;
} SqList;

void InitSqList(SqList &L){
    for (int i = 0; i < MaxSize; i++){
        L.data[i] = 0;
    }
    return ;
}

// 在第i个位置上插入某一个元素
bool ListInsert(int i, int e, SqList &L){
    // 判断 i是否有效
    if (i < 1 || i > L.length + 1) return false;
    // 判断顺序表是否已满
    if (L.length >= MaxSize) return false;
    // 将第i个及其后面的元素后移，从最后的元素开始挪
    // 我在这踩坑了，注意循环次数，以免少挪一位
    for (int j = L.length; j >= i; j--){
        L.data[j] = L.data[j-1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

// 删除，删除表中第i个位置的元素，并用e返回删除元素的值
bool ListDelete(int i, int &e, SqList &L){
    if (i < 1 || i > L.length + 1) return false;
    if (L.length <= 0) return false;
    e = L.data[i - 1];
    for (int j = i; j <= L.length - 1; j++){
        L.data[j - 1] = L.data[j];
    }
    L.data[L.length - 1] = 0;
    L.length--;
    return true;
}

int main (){
    SqList L;
    int e;
    InitSqList(L);
    ListInsert(1, 1, L);
    ListInsert(2, 2, L);
    ListInsert(3, 3, L);
    ListInsert(3, 4, L);
    ListDelete(3, e, L);
    for(int i = 0 ; i< L.length; i++){
        cout<< L.data[i]<<endl;
    }
    cout<< e <<endl;
    return 0;
}


```

## 2.3 链表

### 2.3.1 单链表的定义

|      | 顺序表                           | 链表                           |
| ---- | -------------------------------- | ------------------------------ |
| 优点 | 空间密度高，可随机存取           | 改变容量方便                   |
| 缺点 | 要求大片连续空间，改变容量不方便 | 不可随机存取，要耗费空间放指针 |

```cpp
#include<iostream>
using namespace std;

// 注意写法，*LNode更侧重节点，LinkList更侧重链表
typedef struct LNode{
    int data;
    LNode *next;
} LNode, *LinkList;

// 不带头节点的链表
void InitListNoHead (LinkList &L){
    L->next = NULL;
}

// 带头结点的链表
void InitList (LinkList &L){
    L = new LNode;
    L->next = NULL;
}

int main(){
    // 测试初始链表
    LinkList L;
    InitList(L);
    LNode *p = L;
    for (int i = 0; i < 5; i++){
        p->next = new LNode;
        p = p->next;
        p->data = i;
        p->next = NULL;
    }
    p = L->next;
    while(p != NULL) {
        cout << p->data <<endl;
        p = p->next;
    }
    return 0;
}
```

### 2.3.2单链表的插入、删除、求长度

插入最好时间复杂度O(1)，平均O(n)

删除最好时间复杂度O（1），平均O（n）

```cpp
#include<iostream>
using namespace std;

typedef struct LNode{
    int data;
    LNode* next;
} LNode, *LinkList;

void InitList(LinkList &L){
    L = new LNode;
    L->next = NULL;
}

void InitListNoHead(LinkList &L){
    L = new LNode;
    L = NULL;
}

// 求长度(头结点不算)
int ListLength(LinkList &L){
    int len = 0;
    LNode* p = L->next;
    while(p != NULL) {
        len++;
        p = p->next;
    }
    return len;
}

// 在第i个位置插入e数据
bool ListInsert(LinkList &L, int i ,int e){
    int len = ListLength(L);
    if(i < 1 || i > len + 1) return false;
    LNode *p = L;
    // 找到第i个位置的上一个节点
    for(int j = 0; j < i - 1; j++){
        p = p->next;
    }
    LNode *q = p->next;
    p->next = new LNode;
    p->next->data = e;
    p->next->next = q;
    return true;
}

// 指定节点的前插
void InsertPriorNode(LNode* p, int e){
    // 遍历做不到，直接将此节点的副本查到自己的后面然后改变自己的数据
    LNode *q = p->next;
    p->next = new LNode;
    p->next->data = p->data;
    p->next->next = q;
    p->data = e;
}

// 删除第i个位置的节点并返回删除的数据
bool ListDelete(LinkList &L, int i, int &e){
    int len = ListLength(L);
    if(i < 1 || i > len + 1) return false;
    LNode *p = L;
    // 找到第i个位置的上一个节点
    for(int j = 0; j < i - 1; j++){
        p = p->next;
    }
    LNode *q = p->next->next;
    e = p->next->data;
    delete p->next;
    p->next = q;
    return true;
}

int main(){
    // 测试初始链表
    LinkList L;
    InitList(L);
    LNode *p = L;
    for (int i = 0; i < 5; i++){
        p->next = new LNode;
        p = p->next;
        p->data = i;
        p->next = NULL;
    }

    InsertPriorNode(p, 11110);

    ListInsert(L, 3, 11);
    ListInsert(L, 7, 111);
    ListInsert(L, 9, 1111);
    
    int e = 0;
    ListDelete(L, 7, e);
    cout << e << endl;

    p = L->next;
    while(p != NULL) {
        cout << p->data <<endl;
        p = p->next;
    }
    return 0;
}
```

### 2.3.3 单链表的查找

平均时间复杂度都是O（n）

```cpp
//按位查找，返回第i个节点
LNode * GetElem(LinkList L, int i){
    // 省略判断i是否合法
    LNode *p = L;
    for (int j = 0; j < i; j++){
        p = p->next;
    }
    return p;
}

//按值查找，返回节点
LNode * LocateElement(LinkList L, int e){
    // 省略判断是否合法
    LNode *p = L;
    while(p != NULL){
        p = p->next;
        if(p->data == e){
            return p;
        }
    }
    return NULL;
}
```

### 2.3.4 头插尾插建立单链表

```cpp
#include<iostream>
using namespace std;

// 注意写法，*LNode更侧重节点，LinkList更侧重链表
typedef struct LNode{
    int data;
    LNode *next;
} LNode, *LinkList;

// 不带头节点的链表
void InitListNoHead (LinkList &L){
    L->next = NULL;
}

// 带头结点的链表
void InitList (LinkList &L){
    L = new LNode;
    L->next = NULL;
}

// 头插法
void List_HeadInsert(LinkList &L, int e){
    LNode *p = L->next;
    L->next = new LNode;
    L->next->data = e;
    L->next->next = p;
}

// 尾插法，其实前面三节用的测试链表就是尾插法，这里只是单独元素的尾插，循环尾插见这些代码的main函数
void List_TailInsert(LinkList &L, int e){
    // 先遍历到尾巴
    LNode *p = L;
    while(p->next != NULL){
        p = p->next;
    }
    p->next = new LNode;
    p->next->data = e;
    p->next->next = NULL;
}

int main(){
    // 测试初始链表
    LinkList L;
    InitList(L);
    LNode *p = L;
    List_HeadInsert(L, 100);
    List_TailInsert(L, 200);
    for (int i = 0; i < 5; i++){
        p->next = new LNode;
        p = p->next;
        p->data = i;
        p->next = NULL;
    }
    List_HeadInsert(L, 101);
    List_TailInsert(L, 201);
    p = L->next;
    while(p != NULL) {
        cout << p->data <<endl;
        p = p->next;
    }
    return 0;
}
```

### 2.3.5 双链表

```cpp
#include<iostream>
using namespace std;

typedef struct DNode{
    int data;
    DNode *prior, *next;
} DNode, *LinkList;

void InitList(LinkList &L){
    L = new DNode;
    L->prior = NULL;
    L->next = NULL;
}

// 在P节点后插入s节点
void InsertNextDNode(DNode *p, DNode *s){
    s->next = p->next;
    p->next = s;
    s->prior = p;
    // 注意考虑s的下一个节点是NULL的情况
    if(s->next != NULL) 
        s->next->prior =s;
}

// 删除p节点的后续节点
void DeleteNextDNode(DNode *p){
    if (p->next == NULL) return;
    // 这段写得是真抽象
    if (p->next->next == NULL){
        delete p->next;
        p->next = NULL;
    }else{
        p->next = p->next->next;
        delete p->next->prior;
        p->next->prior = p;
    }
}

int main(){
    LinkList L ;
    InitList(L);
    DNode *s = new DNode;
    s->data = 1;
    DNode *r = new DNode;
    r->data = 2;
    InsertNextDNode(L,s);
    InsertNextDNode(L,r);
    DeleteNextDNode(L);

    DNode *p = L->next;
    while(p != NULL) {
        cout << p->data <<endl;
        p = p->next;
    }
    return 0;
}
```

### 2.3.6 循环链表

```cpp
#include<iostream>
using namespace std;

// 注意循环链表的头节点也算在循环内！
// 循环单链表
typedef struct CNode{
    int data;
    CNode *next;
} CNode, *LinkList;

void InitList (LinkList &L){
    L = new CNode;
    L->next = L;
}

// 循环双链表
typedef struct CDNode{
    int data;
    CDNode *next, *prior;
} CDNode, *LinkListDouble;

void InitListDouble(LinkListDouble &L){
    L = new CDNode;
    L->next = L;
    L->prior = L;
}

// 判断链表是否为空
bool Empty(LinkList &L){
    if(L->next == L) return true;
    return false;
}

// 判断节点P是否为链表的头节点
bool isTail(LinkList L, CNode *p){
    if(p->next == L) return true;
    return false;
}

int main(){

    return 0;
}
```

# 第三章 栈、队列和数组

## 3.1 栈

栈是一种只允许在一端插入或删除的线性表。

栈的操作特性可以概括为后进先出。

|                  |                    |
| ---------------- | ------------------ |
| InitStack(&S)    | 初始化空栈         |
| StackEmpty(S)    | 判断一个栈是否为空 |
| Push(&S, x)      | 进栈               |
| Pop(&S, &x)      | 出栈，用x返回      |
| GetTop(S, &x)    | 读栈顶元素         |
| DestroyStack(&S) | 销毁栈             |

```cpp
#include<iostream>
#define MaxSize 10
using namespace std;

// 顺序栈，设一个指针指示当前栈顶元素
/*
    下列代码的top指的是栈顶元素而不是栈顶上面的空间。
    设初始top = -1，栈满 top = MaxSize - 1
    栈空 top = -1, 栈长 len = top + 1 
*/
typedef struct{
    int data[MaxSize];
    int top;
} SqStack;

// 初始化
void InitStack(SqStack &S){
    S.top = -1;
}

// 栈空
bool StackEmpty(SqStack S){
    if(S.top == -1) return true;
    return false;
}

// 栈满
bool StackFull(SqStack S){
    if(S.top == MaxSize - 1) return true;
    return false;
}

// 进栈
bool Push(SqStack &S, int x){
    if(S.top >= MaxSize - 1) return false;
    S.top++;
    S.data[S.top] = x;
    return true;
}

// 出栈
bool Pop(SqStack &S, int &x){
    if(S.top == -1) return false;
    x = S.data[S.top];
    S.top --;
    return true;
}

// 读栈顶元素
bool GetTop(SqStack &S, int &x){
    if(S.top == -1) return false;
    x = S.data[S.top];
    return true;
}

// 链栈
typedef struct LinkNode{
    int data;
    LinkNode * next;
} LiStack;

int main(){
    // 没啥技术难度就没写测试代码
    return 0;
}
```

## 3.2 队列

只允许在表的一端进行插入，在表的另一端进行删除。操作特性是先进先出。

|                 |                      |
| --------------- | -------------------- |
| InitQueue(&Q)   | 初始化空队列         |
| QueueEmpty(Q)   | 判断一个队列是否为空 |
| EnQueue(&Q, x)  | 进栈                 |
| DeQueue(&Q, &x) | 出栈，用x返回        |
| GetHead(Q, &x)  | 读栈顶元素           |

```cpp
#include<iostream>
#define MaxSize 10
using namespace std;

// 这里有队头指针front和队为指针rear，队尾内的元素是空的
/*
    直接过渡到循环队列
    初始操作：Q.front = Q.rear = 0;
    进队操作：队不满时先送值至队尾元素再将队尾指针加1
    出队操作：队不空时先取队头元素值，再将队头指针加1

    这里使用牺牲一个单元区分队空or队满，约定以队头指针在队尾指针的下一个位置作为队满的标志
*/
typedef struct{
    int data[MaxSize];
    int front, rear;
} SqQueue;

void InitQueue(SqQueue &Q){
    Q.front = Q.rear = 0;
}

bool QueueEmpty (SqQueue Q){
    if(Q.front == Q.rear) return true;
    return false;
}

bool QueueFull (SqQueue Q){
    if((Q.front + 1) % MaxSize == Q.rear) return true;
    return false;
}

bool EnQueue(SqQueue &Q, int x){
    if(QueueFull(Q)) return false;
    Q.data[Q.rear] = x;
    Q.rear = (Q.rear + 1) % MaxSize;
    return true;
}

bool DeQueue(SqQueue &Q, int x){
    if(QueueEmpty(Q)) return false;
    x = Q.data[Q.front];
    Q.front = (Q.front + 1) % MaxSize; // 注意这里是+1
    return true;
}
/*
    链式队列，本质是同时有头指针和尾指针的单链表。头指针指向头节点，尾指针指向尾节点
    注意这里的rear是最后一个节点，有值；带头结点front的下一个节点有值，和顺序队列不一样
*/
typedef struct LinkNode{
    int data;
    LinkNode *next;
} LinkNode;
typedef struct{
    LinkNode *front, *rear;
} *LinkQueue;

// 这里使用的是带头节点的链式存储
void InitLinkQueue(LinkQueue &Q){
    Q->front = new LinkNode;
    Q->rear = Q->front;
    Q->rear->next = NULL;
}

// 链表队列没有栈满的问题
void EnLinkQueue(LinkQueue &Q, int x){
    LinkNode *p = new LinkNode;
    p->data = x;
    Q->rear->next = p;
    Q->rear = p;
    Q->rear->next = NULL;
}

// 出队
bool DeLinkQueue(LinkQueue &Q, int& x){
    if(Q->front == Q->rear) return false;
    LinkNode *p = new LinkNode;
    p = Q->front->next;
    x = p->data;
    Q->front->next = p->next;
    // 当删到最后一位时，注意别丢了rear
    if(Q->rear == p) Q->rear = Q->front;
    delete p;
    return true;
}

int main(){
    // 逻辑难度不大，不做测试
    return 0;
}
```

## 3.3 栈和队列的应用

中缀转后缀，实在写不出来用的chatgpt

```cpp
#include<iostream>
#include<string>
using namespace std;
#define MaxSize 100

// fw 这都得用chatgpt

typedef struct{
    char data [MaxSize];
    int top = -1;
} SqStack;

// 初始化
void InitStack(SqStack &S){
    S.top = -1;
}

// 栈空
bool StackEmpty(SqStack S){
    if(S.top == -1) return true;
    return false;
}

// 栈满
bool StackFull(SqStack S){
    if(S.top == MaxSize - 1) return true;
    return false;
}

// 进栈
bool Push(SqStack &S, char x){
    if(S.top >= MaxSize - 1) return false;
    S.top++;
    S.data[S.top] = x;
    return true;
}

// 出栈
bool Pop(SqStack &S, char &x){
    if(S.top == -1) return false;
    x = S.data[S.top];
    S.top --;
    return true;
}

// 读栈顶元素
bool GetTop(SqStack &S, char &x){
    if(S.top == -1) return false;
    x = S.data[S.top];
    return true;
}

// 中缀转后缀
string ExpressionEvaluation(SqStack &S, string str){
    int len = str.length();
    string outcome;

    for (int i = 0; i < len; i++){

        // 遇到操作数直接加入后缀表达式
        if(isalpha(str[i])) outcome += str[i];

        // 遇到界限符，左括号直接入栈，右括号将栈内到左括号之前的元素弹出加入到后缀表达式
        else if (str[i] == '(') Push(S, str[i]);
        else if (str[i] == ')') {
            char top;
            Pop(S, top);
            while(top != '('){
                outcome += top;
                Pop(S, top);
            }
        }

        // 遇到运算符
        else if (str[i] == '*' || str[i] == '/') {
            char topElem;
            // 如果栈不空且栈顶元素的优先级大于当前运算符的优先级，将栈顶元素出栈并加入到后缀表达式中
            while (!StackEmpty(S) && (GetTop(S, topElem) && (topElem == '*' || topElem == '/'))) {
                outcome += topElem;
                Pop(S, topElem);
            }
            // 当前运算符入栈
            Push(S, str[i]);
        }
        
        // 对于加减运算符，其优先级最低，在遇到加减运算符时，将栈中所有运算符出栈并加入到后缀表达式中
        else if (str[i] == '+' || str[i] == '-') {
            char topElem;
            while (!StackEmpty(S) && (GetTop(S, topElem) && (topElem == '+' || topElem == '-' || topElem == '*' || topElem == '/'))) {
                outcome += topElem;
                Pop(S, topElem);
            }
            // 当前运算符入栈
            Push(S, str[i]);
        }
    }
    
    // 将栈中剩余的运算符依次弹出并加入到后缀表达式中
    while (!StackEmpty(S)) {
        char topElem;
        Pop(S, topElem);
        outcome += topElem;
    }

    return outcome;
}

int main(){
    SqStack S;
    InitStack(S);
    string postfix = ExpressionEvaluation(S, "A+B*(C-D)-E/F");
    cout << postfix << endl;
    return 0;
}

```

## 3.4数组和特殊矩阵

**对称矩阵**

若n阶方阵中任意一个元素ai,j都有ai,j=aj,i，则该矩阵称为对称矩阵

三个区域：i < j 上三角区；i = j 主对角线；i > j 下三角区

策略：按行优先原则将各元素存入一维数组B[k]中。

按行优先的原则，ai,j是第几个元素？(k从0开始, i , j 从1开始)

k = 1 + 2 + ... + i - 1 + j - 1 = i(i - 1)/2 + j - 1 （下三角区域和主对角线元素）



上下三角矩阵

策略：按行优先原则将各元素存入一维数组B[k]中，**并在最后存储一个常量C**。

上三角：

k = i(i - 1)/2 + j -1 (i≥j)

k = n(n+1)/2 （因为上半三角存的都是同一个常数c）



下三角：

k  = n + (n - 1) + ... + (n - i + 2) + j - i = (i - 1)(2n - i +2)/2 + (j - i) (i ≤ j)

k = n(n + 1) / 2



**三对角矩阵**

按行优先原则，ai,j是第几个元素？（k从0开始，i, j从1开始）

k = 2 + 3*(i - 2) + [j - (i - 1)] = 2i + j - 3

已知k求i,j：

![image-20240514201104288](./pic/image-20240514201104288.png)

然后将i向下向上取整。再带入公式求出j.

**稀疏矩阵**

j矩阵中非零元素个数t远远小于矩阵的元素。

三元组存储：将非零元素及其相应的行和列构成一个三元组，按三元组<行，列，值>存储。

十字链表法存储：

![image-20240514201829446](./pic/image-20240514201829446.png)

# 第四章 串

**串指字符串**

## 4.2 串的模式匹配



# 第五章 树与二叉树

## 5.1 树的基本概念

在n个节点的树中有n-1条边

树中一个节点的孩子个数称为该节点的度，树中节点的最大度数称为数的度。

每个节点的分支数就是该节点的度

节点的层次从树根开始算。根节点为第一层，孩子为第二层。结点的深度就是结点所在的层次。树的高度（深度）是树中节点的最大层数。结点的高度是以该结点为根的子树的高度。

树中各结点的各子树从左到右是有次序的，不能互换，称该树为有序树，否则为无序树。

**树的性质**

1. 树的节点数n等于所有结点的度数之和+1。

2. 度为m的树中第i层上至多有$m^{i-1}$个结点
3. 高度为h的m叉树至多有$(m^{h} - 1)/(m - 1)$个结点：当各层结点数达到最大时，树中最多有1 + m + $m^2$ + ... 个结点（等比数列）
4. 度为m，具有n个结点的树的最小高度h为$\lceil \log_m{[(m-1)n + 1]} \rceil$：已知前n层最多有$(m^{h -1} - 1)/(m - 1)$个结点，这一层填满有$(m^{h} - 1)/(m - 1)$个结点，n的取值范围是$(m^{h -1} - 1)/(m - 1)$ ＜ $(m^{h} - 1)/(m - 1)$ ≤ $(m^{h} - 1)/(m - 1)$
5. 度为m，具有n个结点的树的最大高度h是 n - m + 1：度为m至少有一个节点的度为m，故 h = n - ( m - 1 )

## 5.2 二叉树的概念

二叉树与度为2的树的区别：

* 度为2的树至少有三个结点，而二叉树可以空
* 度为2的有序树的孩子左右是相对的，若某一个结点只有一个孩子则不分左右。但二叉树左右孩子是确定的，即时只有一个孩子也分左右。

**二叉树的性质**

* 非空二叉树上的叶结点数等于度为2的结点数+1，即$n_0 = n_2 + 1$
* 非空二叉树的第k层最多有$2^{k - 1}$个结点
* 高度为h的二叉树至多有$2^{h} - 1$个结点
* 

**几种特殊的二叉树**

满二叉树：

* 一颗高度为h的树，有$2^h - 1$个结点的二叉树称为满二叉树。

完全二叉树：

* 高度为h，有n个结点的二叉树，每一个结点都和满二叉树对应。
* 若 i ≤ $\lfloor n / 2 \rfloor$ ，则结点是非叶子结点
* 若有度为1的结点，最多只会出现一个，且编号为 i = $n / 2 $
* 若n为奇数，则每个分支结点都有左孩子和右孩子，若n为偶数，最后一个孩子是左孩子。
* 约定从根节点编号为1，自上而下，自左向右。每个节点对应一个编号，对于编号为i的节点，若有双亲，则双亲为$\lfloor i / 2 \rfloor$，若有左孩子，则左孩子为2i，若有右孩子，则右孩子为2i+1。
* 结点i所在层次（深度）为$\lfloor log_2{i}\rfloor +1$
* 具有n个结点的完全二叉树的高度为$\lceil log_2(n+1)\rceil$ 或 $\lfloor log_2n \rfloor + 1$： $2^{h - 1} ＜ n ≤ 2^{h} - 1$

二叉排序树：左子树上所有结点的关键字均小于根结点的关键字；右子树上所有结点的关键字均大于根节点的关键字。左子树和右子树都是二叉排序树。

平衡二叉树：树中任意一个结点的左子树和右子树的高度之差的绝对值不超过1。

正则二叉树：树中每个分支结点都有两个2孩子。即树中只有度为0和2的结点。

**二叉树的存储结构**

对于满二叉树和完全二叉树，采用顺序存储比较合适。按行从左只右顺序存储普通二叉树会有0项，浪费空间。

链式存储结构：在含有n个结点的二叉链表中，含有n+1个空链域。

## 5.3 二叉树的遍历和线索二叉树

在n个结点的二叉树中，有n+1个空指针。因为叶结点有两个空指针，度为1的节点有一个，总共有2$n_{0}$ + $n_{1}$个空指针。二叉树的结点关系有$n_{0} = n_{2} + 1$，故空指针共有n+1。

**线索二叉树**

![image-20240520145640038](./pic/image-20240520145640038.png)

![image-20240520160502069](./pic/image-20240520160502069.png)

## 5.4 树和森林

区分树的顺序存储结构与二叉树的顺序存储结构。在树的顺序存储结构中，数组下标代表结点的编号，下标中存储的内容指示了结点之间的关系。而在二叉树的顺序存储结构中，数组下标既代表了结点的编号，又指示了二叉树中各结点之间的关系。二叉树可以用树的存储结构存储，但是树不能用二叉树的存储结构。



**树和森林的遍历**

![image-20240520193509471](./pic/image-20240520193509471.png)

![image-20240520193709506](./pic/image-20240520193709506.png)

## 5.5 树与二叉树的应用

### 5.5.1 哈夫曼树和哈夫曼编码

带权路径长度（Weight Path Length）最小的二叉树称为哈夫曼树，也称最优二叉树。

**哈夫曼树的构造**：反复找到最小权值和的两个结点或树拼成新树。

**哈夫曼树的性质**：

* 每个初始结点都是根结点。权值越小的结点到根结点的路径长度最大。
* 构造过程中共新建了n-1个结点（$n_{0} = n_{2} + 1$），因此哈夫曼树共有2n-1个结点。
* 每次构造都选择两颗树作为新结点的孩子，因此哈夫曼树不存在度为1的结点。

**哈夫曼编码**

可变长度编码对频率高的字符短编码，对频率低的字符长编码。

没有一个编码是另一个编码的前缀，这样的编码为前缀编码。

### 5.5.2 并查集

每个子集合用一棵树表示。所有表示子集合的树，构成表示全集合的森林，存放在双亲表示数组内。通常用数组元素的下标代表元素名，用根结点的下标代表子集合全名，根结点的双亲域为负数（可设置为子集合所有元素个数的相反数）。

为了得到两个子集合的并，只需将其中一个子集合根结点的双亲指针指向另一个集合的根节结点。**用双亲表示法。**

![image-20240520203312610](./pic/image-20240520203312610.png)

# 第六章 图

图G由顶点集V和边集E组成，记为G = (V,E)。V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合。用|V|表示图G中顶点的个数，用|E|表示图G中边的条数。

注：线性表可以是空表，树可以是空树，图不可以是空图。图可以没有边但必须有顶点。

完全图

* 对于无向图，|E|的取值范围是0到n(n-1)/2，有n(n-1)/2条边的无向图称为完全无向图
* 对于有向图，|E|的取值范围是0到n(n-1)，有n(n-1)条边的无向图称为完全有向图

生成子图和子图：子图是图的部分顶点和边的组合，生成子图是图的全部顶点和部分边的组合。

联通图：任意两个顶点是联通的称之为联通图。否则称为非联通图。无向图中的极大联通子图称为联通分量。

强连通图，强连通分量：有向图中两顶点有两条路径则称为强连通图。若图中任意一对顶点都是强连通的，则称此图为强连通图。有向图中的极大强连通子图称为有向图的强连通分量。

度，入度和出度：无向图中的度是依附于顶点v的边的条数，记为TD(v)。有向图中，顶点v的度分为入度和出度。入度和出度的和称为度。

有向树：顶点入度为0，其余顶点的入度为1的有向图，称为有向树。

## 6.2 图的存储及基本操作

### 6.2.1 邻接矩阵法

邻接矩阵表示法的空间复杂度为o($n^2$)，其中n为图的顶点数|V|。

无向图中某一个顶点的度按行或列算；有向图中某一个顶点的出度按行算，入度按列算。

稠密图适合用邻接矩阵的存储表示。



**邻接矩阵的性质**

![image-20240603203531996](./pic/image-20240603203531996.png)

每一个因式表示两点之间是否存在路径，若不存在路径则为0，存在路径则为1。最后可得$A^2$

![image-20240603203856350](./pic/image-20240603203856350.png)

### 6.2.2 邻接表法

邻接表是对图G中的每个顶点都建立一个单链表。每一个单链表中的节点表示依附于顶点v的边，这个单链表称为这个顶点的**边表（存边）**。边表的头指针和顶点的数据采用顺序存储，称为**顶点表（存顶点）**。在邻接表中存在两种结点：顶点表结点和边表结点。

每一个顶点的边表中，边出现的顺序是任意的，所以一张图的邻接表可能有不止一个。有向图中一个顶点的边表**只有出度**。

邻接表法和树的孩子兄弟表示法极其相似。

<img src="./pic/image-20240603202033562.png" alt="image-20240603202033562" style="zoom:50%;" />

<img src="./pic/image-20240603202103021.png" alt="image-20240603202103021" style="zoom: 33%;" />

![image-20240603202903478](./pic/image-20240603202903478.png)

### 6.2.3 十字链表

![image-20240606194842785](./pic/image-20240606194842785.png)

注：弧头是有箭头的一段，弧尾是出发点。

在十字链表中，既容易找到Vi为尾的弧，也用于找到Vi为头的弧，因而容易求出顶点的出度和入度。图的十字链表不是唯一的，但一个十字链表可以确定一个唯一的图。

空间复杂度：O(|V|+|E|)

找一个节点的入度：顺着结点的firstin找

找一个结点的出度：顺着结点的firstout找

**十字链表只能存有向图**

### 6.2.4 邻接多重表

![image-20240606200556497](./pic/image-20240606200556497.png)

![image-20240606200734425](./pic/image-20240606200734425.png)

空间复杂度：O(|V|+|E|)

**邻接多重表只适合于无向图**

## 6.3 图的遍历

### 6.3.1 广度优先遍历 BFS 

BFS算法需要借助辅助队列Q，n个顶点均需入队一次。在最坏的情况下空间复杂度为O(|V|)

采用邻接表存储时，每个顶点需要搜索一次，每一个顶点的每一条边需要访问一次，故时间复杂度为O(|V|+|E|)

采用邻接矩阵存储时，每个顶点需要搜索一次，每个顶点需要遍历其他所有顶点查询边，故时间复杂度为O($|V|^2$)

同一个图的邻接表表示方法不唯一，故**BFS序列不唯一**，广度优先遍历树也不唯一；同一个图的邻接矩阵表示方法唯一，故**BFS序列唯一**，广度优先遍历树唯一。



**BFS算法求解单源最短路径问题**

使用BFS可以求解非带权图的单源最短路径问题，这是由广度优先搜索总是按照距离由近到远来遍历图中每个顶点的性质决定的。

### 6.3.2 深度优先遍历 DFS 

DFS算法是递归算法，需要借助递归工作栈，故空间复杂度为O(|V|)

采用邻接表存储时，每个顶点需要搜索一次，每一个顶点的每一条边需要访问一次，故时间复杂度为O(|V|+|E|)

采用邻接矩阵存储时，每个顶点需要搜索一次，每个顶点需要遍历其他所有顶点查询边，故时间复杂度为O($|V|^2$)

同理，同一个图的邻接表表示方法不唯一，故**DFS序列不唯一**，深度优先遍历树也不唯一；同一个图的邻接矩阵表示方法唯一，故**DFS序列唯一**，深度优先遍历树唯一。

### 6.3.3 图的遍历与联通性

对于无向图，BFS和DFS调用的次数为连通分量的数量。

对于有向图，若第一个遍历的节点到其他任意节点都有路径，则BFS和DFS调用的次数为1；若图为强连通图，则从任意顶点出发都只需调用1次函数。

## 6.4 图的应用

* 最小生成树
* 最短路径
* 拓扑排序
* 关键路径

### 6.4.1 最小生成树 MST

对于一个带权连通无向图G，生成树不同，每棵树的权不同。权值最下的树称为最小生成树（Minimum-Spanning-Tree, MST）

**最小生成树的性质**

* 图G中存在权值相同的边，则G的最小生成树可能不唯一。当图G中不存在权值不同的树，则最小生成树是唯一的。
* 当无向连通图G的边数比顶点少1时，本身就是自己的最小生成树
* 虽然最小生成树不唯一，但其对应的边的权值之和总是唯一的，而且是最小的
* 最小生成树的边数为顶点数减1
* 最小生成树的所有的边权值最小，但不能保证任意两个顶点之间的路径是最短路径

最小生成树算法主要有Prim和Kruskal算法，均基于贪心算法的策略。

**Prim算法**

每次选择和当前顶点集合权值最小的边，并将对面的节点加入集合。

时间复杂度：O($|V|^2$)，不依赖于|E|，因此它适用于求解边稠密的图的最下生成树

**Kruskal算法**

每次选择两个不在同一个集合的且用权值最小的边连接的两个顶点，使用并查集判断两个顶点是否在一个集合。

时间复杂度：O($|E|log_2|E|$)

### 6.4.2 最短路径

带权路径长度最短的一条叫最短路径，可能不止一条。

求解最短路径的算法都依赖于一种性质：即两点之间的最短路径也包含了路径上其他顶点间的最短路径。

带权有向图G的最短路径问题一般分为两类：

* 一是单源最短路径，即求图中某一个顶点到其他各顶点的最短路径。以Dijkstra算法为例
* 二是求每对顶点之间的最短路径，可以通过Floyd算法求解

**Dijkstra算法求单源最短路径问题**

BFS只适合求无权图的最短路径

![image-20240610130438205](./pic/image-20240610130438205.png)

三个数组：

Final[]：用于标记该节点是否找到与源节点的最短路径

Dist[]：用于记录与源节点的最短路径。初始时，自己是0，有与源节点直接相连的写弧的权值， 没有直接相连的弧写无穷

Path[]：用于记录该结点的最短路径前驱结点。初始时，自己和没有直接与源节点弧相连的结点是-1，有何源节点直接相连的结点写源节点

每一轮中：

①扫描Final数组，找到所有Final为false（没有找到最短路径）的结点

②比较上述结点的Dist[]数据大小，找到最小的（看谁离源点最近）结点

③遍历其后驱结点

④将path[]数组的后继结点的内容写上自己

⑤将dist[]数组的后继结点内容写上源节点到自己的权值加上自己到对应后继结点的权值

⑥将这个结点的Final[]标记为true

重复上述操作直至final数组没有false。

重复n-1轮，由于每一轮都要扫描dist[]数组花费n，并且要找到后继结点（不一定），故**时间复杂度**可计算为n-1*O(n) = O($n^2$)

由于prim和dijkstra算法类似，时间复杂度也类似。

**若权值为负则Dijkstra算法会失效**



**Floyd算法**

已知一个各边权值均大于0的带权有向图，对任意两个顶点$v_i$≠$v_j$，求出两个顶点之间的最短路径和最短路径长度。

![image-20240610141636260](./pic/image-20240610141636260.png)

两个方阵：

$A^{(n)}[i][j]$：表示两点之间的最短路径，列结点表示起点，行结点表示终点。初始时，自己写0，没有直接相连的节点写无穷，n为-1。

$path^{(n)}[i][j]$：表示两点之间的中转点。初始时，没有中转点和自己写-1，n为-1。

每一轮中：

①将两个数组的上标加1，表示从在第n、n-1、...、0号结点的中转下，两节点之间的距离和中转结点是什么。（没有再代码上体现）

②若$A^{(n-1)}[i][n] + A^{(n-1)}[n][i] < A^{(n-1)}[i][j]$，即中转后距离变小了，则更新两个矩阵，令$A^{(n)}[i][j] = A^{(n-1)}[i][n] + A^{(n-1)}[n][i]$，令$path^{n}[i][j]=n$

代码体现：

![image-20240610143250167](./pic/image-20240610143250167.png)

**时间复杂度**：O($n^3$)，**空间复杂度**：O($n^2$)

**Floyd算法可以解决负权图，但不能解决负权回路的图。**

![image-20240610145516567](./pic/image-20240610145516567.png)

![image-20240610145536968](./pic/image-20240610145536968.png)

### 6.4.3 有向无环图 DAG

![image-20240610150045421](./pic/image-20240610150045421.png)

![image-20240610150059169](./pic/image-20240610150059169.png)

注意箭头的指向。

### 6.4.4 拓扑排序 AOV网

AOV网：若用有向无环图表示一个工程，其顶点表示活动，用有向边<$V_{i}, V_{j}$>表示活动$V_{i}$必须先于活动$V_{j}$进行的这样一种关系，将这种有向图称为**顶点表示活动的网络**，简称AOV网。

在AOV网中，活动$V_{i}$是活动$V_{j}$的直接前驱，后者是前者的直接后继，这种前驱和后继关系具有传递性，且任何活动$V_{i}$不能以它自己的前驱或者后继。

**拓扑排序**：在图论中，由一个有向无环图的顶点组成的序列，当且满足下列条件时，称为该图的一个拓扑排序：

① 每个顶点出现且只出现一次

② 若顶点A在序列中排在顶点B前面，则在图中不存在从B到A的路径

或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中B出现在A的后面。每个AOV网都有一个或多个拓扑排序序列。

得到拓扑排序的步骤：

从AOV网中选择一个入度为0的结点，输出结点，删除其出度和结点。重复直至AOV网为空或当前网中不存在无前驱的顶点为止。后一种情况标明有向图中必然存在环。



**时间复杂度**：邻接矩阵O($n^2$)，邻接表O(|E|+|V|)。我也不明白为啥时间复杂度是这样。



**DFS实现拓扑排序的思想：**弹出递归栈的时候输出当前 结点。

**逆拓扑排序**：先找到一个没有后继的结点。

**唯一性与存在性**：拓扑排序不一定唯一。对于一般的图来说，若其邻接矩阵是三角矩阵，则存在拓扑排序；反之则不成立。



### 6.4.5 关键路径 AOE网

AOE网：用边表示活动的网络，与AOV网不同在于其边有权值。

AOE网的两大性质：

① 只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始

② 只有在进入某一个顶点的各有向边所代表的活动都已经结束时，该顶点所代表的事件才能发生。

在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），它表示整个工程的开始。也只有一个出度为0的顶点，称为结束顶点，它表示整个工程的结束。

**关键路径**：源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径，而把关键路径上的活动称为**关键活动**。

求关键路径的步骤：

① 求所有事件的最早发生时间 ve()

![image-20240610181220469](./pic/image-20240610181220469.png)

② 求所有事件的最迟发生时间 vl()

![image-20240610181701795](./pic/image-20240610181701795.png)

③ 求所有活动的最早发生时间 e() ：弧尾所连事件的最早发生时间

④ 求所有活动的最迟发生时间l()：弧头所连事件的最晚发生时间－活动时间

⑤ 求所有活动的时间余量 d() = l() - e()

缩短关键活动的时间，可以缩短整个工程的工期；当缩短到一定程度时，关键活动可能会变成非关键活动。

有的AOE网可能存在多条关键路径，只有加快所有关键路径的关键活动才能缩短工期。



**采用不同存储结构时各种图算法的时间复杂度**

|               | Dijkstra           | Floyd              | Prim       | Kruskal    | DFS      | BFS            | 拓扑排序 | 关键路径 |
| ------------- | ------------------ | ------------------ | ---------- | ---------- | -------- | -------------- | -------- | -------- |
| 邻接矩阵      | O($n^2$)           | O($n^3$)           | O($n^2$)   |            | O($n^2$) | O($n^2$)       | O($n^2$) | O($n^2$) |
| 邻接表        |                    |                    |            | O(eloge)   | O(n+e)   | O(n+e)         | O(n+e)   | O(n+e)   |
| 有向图/无向图 | 有向图             | 有向图             | 无向图     | 无向图     | 都可以   | 都可以         | 有向图   | 有向图   |
| 是否带权      | 是                 | 是                 | 是         | 是         | 否       | 否             | 否       | 是       |
| 求什么        | 所有点到某点的路径 | 图中每两个点的路径 | 最小生成树 | 最小生成树 | 拓扑排序 | 无权图最短路径 |          |          |



