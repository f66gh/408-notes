# 第二章 线性表 Linear List

线性表是相同数据类型的n个数据元素的有限序列。线性表是一种**逻辑结构**，表示元素之间一对一的相邻关系。顺序表和链表是**存储结构**。

线性表的基本操作：

| InitList(&L)          | 初始化表                                 |
| --------------------- | ---------------------------------------- |
| Length(L)             | 求表长                                   |
| LocateElement(L,e)    | 按值查找操作                             |
| GetElem(L,i)          | 按位查找操作                             |
| ListInsert(&L, i, e)  | 插入操作                                 |
| ListDelete(&L, i, &e) | 删除操作，删除第i个元素的位置，用e返回值 |
| PrintList(L)          | 输出操作                                 |
| Empty(L)              | 判空操作                                 |
| DestoryList(&L)       | 销毁操作                                 |

## 2.2 线性表的顺序表示

线性表的顺序存储又称为顺序表。他是用一组地址连续的存储单元依次存储线性表的数据元素，**从而使得逻辑上相邻的两个元素在物理位置上也相邻**。

**顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。**

顺序表的特点：

* 随机访问，在O(1)找到第i个元素
* 存储密度高
* 拓展容量不方便
* 插入删除不方便，需要移动大量元素

```cpp
#include <iostream>
using namespace std;

// 静态线性表
#define MAXSIZE 10
typedef struct{
    int data[MAXSIZE];
    int length;
}SqList_Static;

// 动态线性表
typedef struct{
    int *data;
    int MaxSize;
    int length;
}SqList_Dynamic;

//初始化一个顺序表
void InitList(SqList_Static &L){
    for(int i = 0; i < MAXSIZE; i++){
        L.data[i] = 0;
    }
    L.length = 0;
}

void InitList_Dynamic(SqList_Dynamic &L, int MaxSize){
    L.MaxSize = MaxSize;
    L.data = new int [MaxSize];
    L.length = 0;
}

// 增加动态线性表的长度
void IncreaseSize(SqList_Dynamic &L, int len){
    int *p = L.data; //指针指向原数组
    L.data = new int [L.MaxSize + len]; // 顺序表更改存储空间
    for (int i = 0; i < L.length ; i++){
        L.data[i] = p[i]; // 将数据拷贝到新空间
    }
    L.MaxSize += len;
    delete p; // 释放原空间
    return;
}

int main (){
    SqList_Dynamic L;
    int MaxSize = 10;
    InitList_Dynamic(L, MaxSize);
    IncreaseSize(L, 10);

    cout << L.length << endl;

    return 0;
}
```

## 2.3 顺序表的插入和删除

**插入**

时间复杂度最好O(1)，最差O(n)，平均情况O（n）

设元素插入到每一个位置的概率都相同，p = 1/(n+1)，平均时间复杂度= np + (n-1)p + ... + p = n(n+1)/2  * 1/(n+1) = n/2 = O(n)

**删除**

时间复杂度最好O(1)，最差O(n)，平均O(n)

```cpp
#include<iostream>
#define MaxSize 10
using namespace std;

typedef struct{
    int data[MaxSize];
    int length = 0;
} SqList;

void InitSqList(SqList &L){
    for (int i = 0; i < MaxSize; i++){
        L.data[i] = 0;
    }
    return ;
}

// 在第i个位置上插入某一个元素
bool ListInsert(int i, int e, SqList &L){
    // 判断 i是否有效
    if (i < 1 || i > L.length + 1) return false;
    // 判断顺序表是否已满
    if (L.length >= MaxSize) return false;
    // 将第i个及其后面的元素后移，从最后的元素开始挪
    // 我在这踩坑了，注意循环次数，以免少挪一位
    for (int j = L.length; j >= i; j--){
        L.data[j] = L.data[j-1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

// 删除，删除表中第i个位置的元素，并用e返回删除元素的值
bool ListDelete(int i, int &e, SqList &L){
    if (i < 1 || i > L.length + 1) return false;
    if (L.length <= 0) return false;
    e = L.data[i - 1];
    for (int j = i; j <= L.length - 1; j++){
        L.data[j - 1] = L.data[j];
    }
    L.data[L.length - 1] = 0;
    L.length--;
    return true;
}

int main (){
    SqList L;
    int e;
    InitSqList(L);
    ListInsert(1, 1, L);
    ListInsert(2, 2, L);
    ListInsert(3, 3, L);
    ListInsert(3, 4, L);
    ListDelete(3, e, L);
    for(int i = 0 ; i< L.length; i++){
        cout<< L.data[i]<<endl;
    }
    cout<< e <<endl;
    return 0;
}


```

## 2.3 链表

### 2.3.1 单链表的定义

|      | 顺序表                           | 链表                           |
| ---- | -------------------------------- | ------------------------------ |
| 优点 | 空间密度高，可随机存取           | 改变容量方便                   |
| 缺点 | 要求大片连续空间，改变容量不方便 | 不可随机存取，要耗费空间放指针 |

```cpp
#include<iostream>
using namespace std;

// 注意写法，*LNode更侧重节点，LinkList更侧重链表
typedef struct LNode{
    int data;
    LNode *next;
} LNode, *LinkList;

// 不带头节点的链表
void InitListNoHead (LinkList &L){
    L->next = NULL;
}

// 带头结点的链表
void InitList (LinkList &L){
    L = new LNode;
    L->next = NULL;
}

int main(){
    // 测试初始链表
    LinkList L;
    InitList(L);
    LNode *p = L;
    for (int i = 0; i < 5; i++){
        p->next = new LNode;
        p = p->next;
        p->data = i;
        p->next = NULL;
    }
    p = L->next;
    while(p != NULL) {
        cout << p->data <<endl;
        p = p->next;
    }
    return 0;
}
```

### 2.3.2单链表的插入、删除、求长度

插入最好时间复杂度O(1)，平均O(n)

删除最好时间复杂度O（1），平均O（n）

```cpp
#include<iostream>
using namespace std;

typedef struct LNode{
    int data;
    LNode* next;
} LNode, *LinkList;

void InitList(LinkList &L){
    L = new LNode;
    L->next = NULL;
}

void InitListNoHead(LinkList &L){
    L = new LNode;
    L = NULL;
}

// 求长度(头结点不算)
int ListLength(LinkList &L){
    int len = 0;
    LNode* p = L->next;
    while(p != NULL) {
        len++;
        p = p->next;
    }
    return len;
}

// 在第i个位置插入e数据
bool ListInsert(LinkList &L, int i ,int e){
    int len = ListLength(L);
    if(i < 1 || i > len + 1) return false;
    LNode *p = L;
    // 找到第i个位置的上一个节点
    for(int j = 0; j < i - 1; j++){
        p = p->next;
    }
    LNode *q = p->next;
    p->next = new LNode;
    p->next->data = e;
    p->next->next = q;
    return true;
}

// 指定节点的前插
void InsertPriorNode(LNode* p, int e){
    // 遍历做不到，直接将此节点的副本查到自己的后面然后改变自己的数据
    LNode *q = p->next;
    p->next = new LNode;
    p->next->data = p->data;
    p->next->next = q;
    p->data = e;
}

// 删除第i个位置的节点并返回删除的数据
bool ListDelete(LinkList &L, int i, int &e){
    int len = ListLength(L);
    if(i < 1 || i > len + 1) return false;
    LNode *p = L;
    // 找到第i个位置的上一个节点
    for(int j = 0; j < i - 1; j++){
        p = p->next;
    }
    LNode *q = p->next->next;
    e = p->next->data;
    delete p->next;
    p->next = q;
    return true;
}

int main(){
    // 测试初始链表
    LinkList L;
    InitList(L);
    LNode *p = L;
    for (int i = 0; i < 5; i++){
        p->next = new LNode;
        p = p->next;
        p->data = i;
        p->next = NULL;
    }

    InsertPriorNode(p, 11110);

    ListInsert(L, 3, 11);
    ListInsert(L, 7, 111);
    ListInsert(L, 9, 1111);
    
    int e = 0;
    ListDelete(L, 7, e);
    cout << e << endl;

    p = L->next;
    while(p != NULL) {
        cout << p->data <<endl;
        p = p->next;
    }
    return 0;
}
```

### 2.3.3 单链表的查找

平均时间复杂度都是O（n）

```cpp
//按位查找，返回第i个节点
LNode * GetElem(LinkList L, int i){
    // 省略判断i是否合法
    LNode *p = L;
    for (int j = 0; j < i; j++){
        p = p->next;
    }
    return p;
}

//按值查找，返回节点
LNode * LocateElement(LinkList L, int e){
    // 省略判断是否合法
    LNode *p = L;
    while(p != NULL){
        p = p->next;
        if(p->data == e){
            return p;
        }
    }
    return NULL;
}
```

### 2.3.4 头插尾插建立单链表

```cpp
#include<iostream>
using namespace std;

// 注意写法，*LNode更侧重节点，LinkList更侧重链表
typedef struct LNode{
    int data;
    LNode *next;
} LNode, *LinkList;

// 不带头节点的链表
void InitListNoHead (LinkList &L){
    L->next = NULL;
}

// 带头结点的链表
void InitList (LinkList &L){
    L = new LNode;
    L->next = NULL;
}

// 头插法
void List_HeadInsert(LinkList &L, int e){
    LNode *p = L->next;
    L->next = new LNode;
    L->next->data = e;
    L->next->next = p;
}

// 尾插法，其实前面三节用的测试链表就是尾插法，这里只是单独元素的尾插，循环尾插见这些代码的main函数
void List_TailInsert(LinkList &L, int e){
    // 先遍历到尾巴
    LNode *p = L;
    while(p->next != NULL){
        p = p->next;
    }
    p->next = new LNode;
    p->next->data = e;
    p->next->next = NULL;
}

int main(){
    // 测试初始链表
    LinkList L;
    InitList(L);
    LNode *p = L;
    List_HeadInsert(L, 100);
    List_TailInsert(L, 200);
    for (int i = 0; i < 5; i++){
        p->next = new LNode;
        p = p->next;
        p->data = i;
        p->next = NULL;
    }
    List_HeadInsert(L, 101);
    List_TailInsert(L, 201);
    p = L->next;
    while(p != NULL) {
        cout << p->data <<endl;
        p = p->next;
    }
    return 0;
}
```

### 2.3.5 双链表

```cpp
#include<iostream>
using namespace std;

typedef struct DNode{
    int data;
    DNode *prior, *next;
} DNode, *LinkList;

void InitList(LinkList &L){
    L = new DNode;
    L->prior = NULL;
    L->next = NULL;
}

// 在P节点后插入s节点
void InsertNextDNode(DNode *p, DNode *s){
    s->next = p->next;
    p->next = s;
    s->prior = p;
    // 注意考虑s的下一个节点是NULL的情况
    if(s->next != NULL) 
        s->next->prior =s;
}

// 删除p节点的后续节点
void DeleteNextDNode(DNode *p){
    if (p->next == NULL) return;
    // 这段写得是真抽象
    if (p->next->next == NULL){
        delete p->next;
        p->next = NULL;
    }else{
        p->next = p->next->next;
        delete p->next->prior;
        p->next->prior = p;
    }
}

int main(){
    LinkList L ;
    InitList(L);
    DNode *s = new DNode;
    s->data = 1;
    DNode *r = new DNode;
    r->data = 2;
    InsertNextDNode(L,s);
    InsertNextDNode(L,r);
    DeleteNextDNode(L);

    DNode *p = L->next;
    while(p != NULL) {
        cout << p->data <<endl;
        p = p->next;
    }
    return 0;
}
```

### 2.3.6 循环链表

```cpp
#include<iostream>
using namespace std;

// 注意循环链表的头节点也算在循环内！
// 循环单链表
typedef struct CNode{
    int data;
    CNode *next;
} CNode, *LinkList;

void InitList (LinkList &L){
    L = new CNode;
    L->next = L;
}

// 循环双链表
typedef struct CDNode{
    int data;
    CDNode *next, *prior;
} CDNode, *LinkListDouble;

void InitListDouble(LinkListDouble &L){
    L = new CDNode;
    L->next = L;
    L->prior = L;
}

// 判断链表是否为空
bool Empty(LinkList &L){
    if(L->next == L) return true;
    return false;
}

// 判断节点P是否为链表的头节点
bool isTail(LinkList L, CNode *p){
    if(p->next == L) return true;
    return false;
}

int main(){

    return 0;
}
```

