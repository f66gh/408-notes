# 第二章 线性表 Linear List

线性表是相同数据类型的n个数据元素的有限序列。线性表是一种**逻辑结构**，表示元素之间一对一的相邻关系。顺序表和链表是**存储结构**。

线性表的基本操作：

| InitList(&L)          | 初始化表                                 |
| --------------------- | ---------------------------------------- |
| Length(L)             | 求表长                                   |
| LocateElement(L,e)    | 按值查找操作                             |
| GetElem(L,i)          | 按位查找操作                             |
| ListInsert(&L, i, e)  | 插入操作                                 |
| ListDelete(&L, i, &e) | 删除操作，删除第i个元素的位置，用e返回值 |
| PrintList(L)          | 输出操作                                 |
| Empty(L)              | 判空操作                                 |
| DestoryList(&L)       | 销毁操作                                 |

## 2.2 线性表的顺序表示

线性表的顺序存储又称为顺序表。他是用一组地址连续的存储单元依次存储线性表的数据元素，**从而使得逻辑上相邻的两个元素在物理位置上也相邻**。

**顺序表中的任意一个数据元素都可以随机存取，所以线性表的顺序存储结构是一种随机存取的存储结构。**

顺序表的特点：

* 随机访问，在O(1)找到第i个元素
* 存储密度高
* 拓展容量不方便
* 插入删除不方便，需要移动大量元素

```cpp
#include <iostream>
using namespace std;

// 静态线性表
#define MAXSIZE 10
typedef struct{
    int data[MAXSIZE];
    int length;
}SqList_Static;

// 动态线性表
typedef struct{
    int *data;
    int MaxSize;
    int length;
}SqList_Dynamic;

//初始化一个顺序表
void InitList(SqList_Static &L){
    for(int i = 0; i < MAXSIZE; i++){
        L.data[i] = 0;
    }
    L.length = 0;
}

void InitList_Dynamic(SqList_Dynamic &L, int MaxSize){
    L.MaxSize = MaxSize;
    L.data = new int [MaxSize];
    L.length = 0;
}

// 增加动态线性表的长度
void IncreaseSize(SqList_Dynamic &L, int len){
    int *p = L.data; //指针指向原数组
    L.data = new int [L.MaxSize + len]; // 顺序表更改存储空间
    for (int i = 0; i < L.length ; i++){
        L.data[i] = p[i]; // 将数据拷贝到新空间
    }
    L.MaxSize += len;
    delete p; // 释放原空间
    return;
}

int main (){
    SqList_Dynamic L;
    int MaxSize = 10;
    InitList_Dynamic(L, MaxSize);
    IncreaseSize(L, 10);

    cout << L.length << endl;

    return 0;
}
```

## 2.3 顺序表的插入和删除

**插入**

时间复杂度最好O(1)，最差O(n)，平均情况O（n）

设元素插入到每一个位置的概率都相同，p = 1/(n+1)，平均时间复杂度= np + (n-1)p + ... + p = n(n+1)/2  * 1/(n+1) = n/2 = O(n)

**删除**

时间复杂度最好O(1)，最差O(n)，平均O(n)

```cpp
#include<iostream>
#define MaxSize 10
using namespace std;

typedef struct{
    int data[MaxSize];
    int length = 0;
} SqList;

void InitSqList(SqList &L){
    for (int i = 0; i < MaxSize; i++){
        L.data[i] = 0;
    }
    return ;
}

// 在第i个位置上插入某一个元素
bool ListInsert(int i, int e, SqList &L){
    // 判断 i是否有效
    if (i < 1 || i > L.length + 1) return false;
    // 判断顺序表是否已满
    if (L.length >= MaxSize) return false;
    // 将第i个及其后面的元素后移，从最后的元素开始挪
    // 我在这踩坑了，注意循环次数，以免少挪一位
    for (int j = L.length; j >= i; j--){
        L.data[j] = L.data[j-1];
    }
    L.data[i - 1] = e;
    L.length++;
    return true;
}

// 删除，删除表中第i个位置的元素，并用e返回删除元素的值
bool ListDelete(int i, int &e, SqList &L){
    if (i < 1 || i > L.length + 1) return false;
    if (L.length <= 0) return false;
    e = L.data[i - 1];
    for (int j = i; j <= L.length - 1; j++){
        L.data[j - 1] = L.data[j];
    }
    L.data[L.length - 1] = 0;
    L.length--;
    return true;
}

int main (){
    SqList L;
    int e;
    InitSqList(L);
    ListInsert(1, 1, L);
    ListInsert(2, 2, L);
    ListInsert(3, 3, L);
    ListInsert(3, 4, L);
    ListDelete(3, e, L);
    for(int i = 0 ; i< L.length; i++){
        cout<< L.data[i]<<endl;
    }
    cout<< e <<endl;
    return 0;
}


```

