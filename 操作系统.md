# 第一章 计算机系统概述

## 1.1 操作系统的基本概念

### 1.1.2 操作系统的特征

操作系统的基本特征：并发、共享、虚拟和异步。**并发和共享是操作系统两个最基本的特征。**

#### 并发

指两个事件或者多个事件在同一时间间隔内发生。宏观上是同时发生的，微观上是交替发生的。

**并行性**是指系统具有同时运算或操作的特征。

#### 共享

指系统中的资源可供内存中多个并发执行的进程使用

**互斥共享方式**：规定一段时间内只允许一个进程访问该资源。这种资源叫做临界资源。例如打印机。

**同时访问方式**：资源可以在一段时间内由多个进程同时访问。在为官上可能是交替地对该资源进行访问，即分时共享。例如磁盘。

#### 虚拟

虚拟是将一个物理上的实体变为若干逻辑上的对应物。用于实现虚拟的技术称为虚拟技术。操作系统的虚拟技术可归纳为：时分复用技术，如虚拟处理器；空分服用技术，如虚拟存储器。

#### 异步

多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停的，它以不可预知的速度向前推进，这就是进程的异步性。

### 1.1.3 操作系统的目标和功能

功能：处理机管理、存储器管理、设备管理和文件管理

目标：向上层提供方便易用的服务

![image-20240623173538753](./pic/image-20240623173538753.png)

#### 操作系统作为计算机系统资源的管理者

**处理机管理**：处理机的分配和运行是以进程（或线程）为基本单位。可归结为对进程的管理。进程管理包括进程控制，进程同步，进程通信，死锁处理，处理机调度等。

**存储器管理**：内存分配与回收、地址映射、内存保护与共享、内存扩充

**文件管理**：计算机中的信息都是以文件的形式存在的。操作系统中负责文件管理的部分称为文件系统。

**设备管理：**主要任务是完成用户的I/O请求。

#### 操作系统作为用户与计算机硬件系统之间的接口

**命令接口**

联机命令接口（交互式命令接口）：例如cmd

脱机命令接口（批处理命令接口）：*.bat

**程序接口**：

可以在程序中进行**系统调用**使用程序接口，只能通过程序代码间接使用。

### 操作系统实现了对计算机资源的扩充

没有任何软件支持的计算机称为裸机。我们常将覆盖了软件的机器称为扩充机器或虚拟机。

## 1.2 操作系统发展历程

### 1.2.1 手工操作阶段

缺点：①用户独占全机。资源利用率低。②CPU等待手工操作，CPU利用不充分。

### 1.2.2 批处理阶段

#### 单道批处理系统

将一批作业以脱机的方式输入磁带，并在系统中配上监督程序。虽然系统对作业的处理是成批进行的，但内存中始终保持一道作业。单道批处理系统的主要特征如下：

* 自动性：不需要人工干预
* 顺序性：先进入内存的作业先完成
* 单道性：内存中仅有一道程序运行。

问题：运行时发出IO请求后高速CPU等待低速的IO完成的状态。

#### 多道批处理系统

当某道程序因请求IO操作而暂停运行时，CPU便立即去运行另一道程序，这是通过中断机制实现的。

特点：

* 多道。计算机内存中同时存放多道相互独立的程序。
* 宏观上并行：同时进入系统的多道程序都处于运行过程中，但都未运行完毕。
* 微观上并行：内存中的多道程序轮流占有CPU，交替执行。

优点：资源利用率高，多道程序共享计算机资源；系统吞吐量大，让CPU一直处于忙碌状态。

缺点：用户响应时间较长；不提供人机交互能力。

#### 分时操作系统

将处理器的运行时间分成分段的时间片，将时间片轮流将处理器分配给各联机作业使用。分时操作系统指多个用户通过终端同时共享一台主机，这些终端连接在主机上，用户可以同时与主机进行交互操作而不干扰。分时操作系统与多道批处理系统不同之处在于是它实现了人机交互。

分时系统的主要特征如下：

* 同时性（多路性）：允许多个终端用户同时使用一台计算机。
* 交互性：用户通过终端采用人机对话的方式直接控制程序运行。
* 独立性：系统中多个用户可以独立的直接控制程序运行。
* 及时性：用户请求能在很短时间内获得相应

#### 实时操作系统

为了能在某个时间限制内完成某些紧急任务而不需要时间片排队，诞生了实时操作系统。

这里的时间限制分为两种情况：硬实时系统（必须在规定时间内完成），软实时系统（可以偶尔违反时间规定）

#### 网络操作系统和分布式计算机系统

网络操作系统实现各台计算机之间数据的相互传送。网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。

分布式计算机系统是由多台计算机组成并满足下了条件的系统：即系统中任一两台计算机通过通信的方式交换信息；系统中每台计算机都具有同等的地位，即没有主机也没有从机；每台计算机上的资源为所有用户共享；系统中的任一台计算机都可以构成一个子系统；任何工作都可以分布在几台计算机上，由它们并行工作，协同完成。**用于管理分布式计算机系统的操作系统称为分布式计算机系统**，特点为：分布性和并行性。

**分布式操作系统与网络操作系统的本质不同是分布式操作系统中的若干计算机相互协同完成同一任务。**

#### 个人计算机操作系统

目前使用最广泛的操作系统。

## 1.3 操作系统的运行环境

### 1.3.1 处理器运行模式

通常CPU执行**两种**不同性质的程序：一种是操作系统**内核程序**；另一种是用户自编程序（**应用程序**）。出于安全考虑，应用程序不能执行特权指令。

* 特权指令：指用户不能直接使用的指令。例如IO指令、关中断指令、内存清零指令、存取用于内存保护的寄存器，送PSW到程序状态字寄存器等的指令。
* 非特权指令：允许用户直接使用的指令。

在具体实现上，将CPU的运行模式划分为**用户态（目态）**和**核心态（管态、内核态）**。

当CPU处于核心态时，CPU可以执行特权指令，**切换到用户态的指令是特权指令**。

CPU处于用户态时，此时CPU**只能执行非特权指令**。应用程序运行在用户态，操作系统内核程序运行在核心态。应用程序向操作系统请求服务时通过使用**访管指令**，访管指令运行在用户态，是非特权指令。

现代操作系统几乎都是分层式的结构。操作系统的各项功能分别被设置在不同的层次上。一些与硬件关联较为紧密的模块，如**时钟管理**，**中断处理**和**设备驱动**等处于最底层。其次是运行频率较高的程序，如**进程管理**、**存储器管理**和**设备管理**等。这两部分构成了操作系统的内核，这部分内容指令运行在核心态。

#### 内核

**内核**是计算机上配置的**底层软件**，它管理着系统的各种资源，可以看做**应用程序和硬件的一座桥梁**，大多数操作系统的内核包括4方面的内容。

**时钟管理**

时钟第一功能是计时。另外，通过时钟中断的管理，可以**实现进程的切换**。例如，在分时操作系统中采用时间片轮转调度，在实时系统中按截止时间控制运行。

**中断机制**

中断机制的初衷是提高多道程序运行时的CPU利用率，使CPU可以在I/O操作期间执行其他指令。逐步发展为各项操作的基础。如键盘鼠标信息输入，进程的管理和调度，系统功能的调用，设备驱动，文件访问等。

中断机制中，**只有一小部分功能属于内核**，它们负责保护和恢复中断现场信息的，转移控制权到相关的程序。**这样可以减少中断的处理时间，提高系统的并行处理能力。**

**原语**

按层次结构设计的操作系统，底层需要有一些公共可被调用、只完成某一个规定操作的小**程序**，通常将具有这些特点的程序称为原语，其特点如下：

* 处于操作系统的**底层**，是最接近硬件的部分
* 这些程序的运行具有**原子性**，一旦调用不可被中断
* 这些程序运行的时间都比较短，而且**调用频繁**。

**定义原语的直接方法是关中断**，让其所有动作不可分割地完成后再打开中断。系统中的**设备驱动**、**CPU切换**、**进程通信**等功能中的部分操作都可以定义成原语，使它们称为内核的组成部分。

**系统控制的数据结构及处理**

系统中用来登记状态信息的数据结构有很多，如作业控制块，进程控制块(PCB)，设备控制块等。为了实现有效的管理，系统中需要一些基本的操作：

* 进程管理：进程状态管理、进程调度和分派、创建与撤销进程控制块。
* 存储器管理：存储器空间与回收等
* 设备管理：缓冲区管理、设备分配和回收等。

**核心态指令实际上包括系统调用类指令和一些针对时钟、中断、和原语的操作指令**

### 1.3.2 中断和异常的概念

在实际操作系统中，CPU运行用户程序时**唯一**能进入这些门的途径就是通过**中断**或**异常**。发生中断或异常时，**运行用户态的CPU会立即进入核心态**，这是通过**硬件**实现的。

#### 中断和异常的定义

中断也称**外中断**，是指来自CPU执行指令外部的事件，通常用于信息输入/输出。如设备发出的I/O中断和时钟中断。

异常也称**内中断**，是指来自CPU执行指令内部的事件。如程序的非法操作码、地址越界、运算溢出、虚存系统的**缺页**及专门的**陷入指令**等引起的事件。异常不能被屏蔽，一旦出现就应该立即处理。

![image-20240623204759121](./pic/image-20240623204759121.png)

#### 中断和异常的分类

外中断可分为**可屏蔽中断**和**不可屏蔽中断**。

* 可屏蔽中断是指通过INTR线发出的中断请求，通过改变**屏蔽字**可以实现多中断，从而使得中断处理更加灵活。

* 不可屏蔽中断是指通过NMI线发出的中断请求，通常是紧急的硬件故障，如电源掉电等。此外，**异常也是不可屏蔽的**。

异常可分为**故障**、**自陷**和**终止**。

* 故障通常是由**指令执行**引发的异常。如非法操作码、缺页故障、除数为0、运算溢出等。
* 自陷是一种事先安排的异常事件，用于**在用户态下调用操作系统内核程序**。如条件陷阱指令、系统调用指令等。
* 终止是指出现了使得CPU无法继续执行的**硬件故障**，如控制器出错、存储器校验错等。

**故障异常和自陷异常属于软件中断（程序性异常），终止异常和外部中断属于硬件中断。**

#### 中断和异常的处理过程

过程大致如下：当CPU执行到第i条指令时检测到一个异常事件，或者执行第i条指令后有中断处理限号，则执行中断或异常处理程序。若终端或异常处理程序能解决问题则在处理程序的最后，CPU通过执行中断或异常返回指令回到被打断的用户程序的第i条指令或第i+1条指令继续执行；若中断或异常处理程序发现是不可恢复的致命错误，则终止用户程序。通常情况下，**对中断和异常的具体处理过程由操作系统（和驱动程序）完成**

### 1.3.3 系统调用

![image-20240623211659568](./pic/image-20240623211659568.png)

系统调用是指用户在**程序**中调用操作系统所提供的一些子功能，它可被视为特殊的**公共子程序**。凡是与贡献资源有关的操作（如存储分配，IO操作，文件管理等）都必须要通过系统调用的方式向操作系统内核提出请求服务，由操作系统内核代为完成。这样可以保证系统的**稳定性**和**安全性**。

系统调用的功能：

* 设备管理
* 文件管理
* 进程控制
* 进程通信
* 内存管理

**系统调用的处理过程**：

1. 先将系统调用号和所需参数压入堆栈，然后调用实际的调用指令，然后执行一个**陷入指令**，将CPU状态从用户态转换为核心态（**由异常的自陷引起**），再后由硬件和操作系统内核程序保护被中断进程的现场。
2. 分析系统陷入类型，转入相应的系统调用处理子程序。
3. 再系统调用处理子程序执行结束后，恢复被中断的或设置新进程的CPU现场，然后接着执行。

![image-20240623213736436](./pic/image-20240623213736436.png)

即：当应用程序执行**陷入指令**，相当于将CPU使用权主动交给了操作系统内核程序（CPU由用户态转换为用户态），然后**操作系统**代为执行相应操作，再将CPU还给用户程序。

## 1.4 操作系统结构

#### ![image-20240623214759506](./pic/image-20240623214759506.png)

![image-20240623215329750](./pic/image-20240623215329750.png)

![image-20240623215202674](./pic/image-20240623215202674.png)

![image-20240623215343553](./pic/image-20240623215343553.png)

![image-20240623215545003](./pic/image-20240623215545003.png)

## 1.5 操作系统引导（Boot）

操作系统引导是指计算机利用CPU运行特定程序，**通过程序识别硬盘，识别硬盘分区，识别硬盘分区上的操作系统，最后通过程序启动操作系统**。

![image-20240623215754552](./pic/image-20240623215754552.png)

详细步骤：

①激活CPU。激活的CPU读取ROM中的boot指令，将指令寄存器置为BIOS（基本输入/输出系统）的第一条指令，即开始执行BIOS的指令。

②**硬件自检。**BIOS在内存最开始的空间构建中断向量表，接下来的POST过程要用到中断功能。

③**加载带有操作系统的硬盘。**BIOS读取Boot Sequence（通过CMOS里保存的启动顺序）。CPU将该存储设备引导扇区的内容加载到内存中。

④ 加载主引导记录（MBR）。硬盘以特定的标识符区分引导硬盘和非引导硬盘。找到引导硬盘之后，加载MBR，告诉CPU去硬盘的哪个主分区装着操作系统。（**识别有操作系统的分区**）

⑤ 扫描硬盘分区表，加载硬盘活动分区。硬盘分区表以特定标识符区分活动分区和非活动分区。找到硬盘活动分区后，开始加载硬盘活动分区，将控制权交给活动分区。

⑥ 加载分区引导记录（PBR）。读取活动分区的第一个扇区，这个扇区称为分区引导记录(PBR)，其作用是寻找并激活分区根目录下用于引导操作系统的程序（启动管理器）。

⑦ 加载启动管理器

⑧ 加载操作系统

# 第二章 进程与线程

## 2.1 进程与线程

### 2.1.1 进程的概念和特征

#### 进程的概念

进程可以更好的描述和控制程序的并发执行，实现操作系统的并发性和共享性。

为了使参与并发执行的每个程序都能**独立的运行**，必须为之配置一个专门的数据结构，称为**进程控制块**(PCB)。系统利用PCB来描述**进程的基本情况和运行状态**，进而控制和管理进程。相应地，由**程序段**、**相关数据段**和**PCB**构成了**进程实体**。

创建进程就是创建进程的PCB；撤销进程就是撤销进程的PCB。

进程是进程实体的运行过程，是系统进程资源分配和调度的一个独立单位。（系统资源指硬件设备服务于某个进程的时间）。

#### 进程的特征

进程是由**多道程序的并发执行**而引出的，它和程序时两个截然不同的概念。程序是静态的，进程是动态的，进程的基本特征是对比单个程序的顺序执行提出的。

* 动态性：是进程最基本的特征。
* 并发性：指多个进程同存于内存中，能在一段时间内同时运行。
* 独立性：进程是一个**能独立运行、独立获得资源和独立接收调度的基本单位。**凡是未建立PCB的程序都不能作为一个独立的单位参与运行。
* 异步性：**由于进程的相互制约，使得进程按各自独立、不可预知的速度向前推进。**异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。

### 2.1.2 进程的组成

进程是一个独立运行单位，是操作系统进程资源分配和调度的基本单位。由以下三部分组成，其中最核心的是进程控制块（PCB）。

#### 进程控制块

进程创建时，操作系统为它新建一个PCB，该结构常驻内存，任意时刻都可以存取，在进程结束时删除。PCB是进程实体的一部分，**是进程存在的唯一标识**。

进程执行时，系统通过其PCB了解进程的现行状态信息，以便操作系统对齐进程控制和管理；进程结束时，系统收回其PCB，该进程随之消亡。

系统总是通过PCB对进程进行控制的，亦即系统唯有通过进程的PCB才能感知到该进程的存在。

<table>
	<tbody>
		<tr>
			<th>进程描述信息</th>
			<th>进程控制和管理信息</th>
			<th>资源分配清单</th>
			<th>处理机相关信息</th>
		</tr>
		<tr>
			<td>进程标识符 (PID)</td>
			<td>进程当前状态</td>
			<td>代码段指针</td>
			<td>通用寄存器值</td>
		</tr>
		<tr>
			<td>用户标识符 (UID)</td>
			<td>进程优先级</td>
			<td>数据段指针</td>
			<td>地址寄存器值</td>
		</tr>
		<tr>
            <td></td>
			<td>代码运行入口地址</td>
			<td>堆栈段指针</td>
			<td>控制寄存器值</td>
		</tr>
		<tr>
            <td></td>
			<td>程序的外存地址</td>
			<td>文件描述符</td>
			<td>标志寄存器值</td>
		</tr>
		<tr>
            <td></td>
			<td>进入内存时间</td>
			<td>键盘</td>
			<td>状态字</td>
		</tr>
		<tr>
            <td></td>
			<td>CPU 占用时间</td>
			<td>鼠标</td>
			<td> </td>
		</tr>
		<tr>
            <td></td>
			<td>信号量使用</td>
			<td> </td>
			<td> </td>
		</tr>
	</tbody>
</table>

* 进程描述信息
* 进程控制和管理信息
* 资源分配清单：用于说明有关内存地址空间或虚拟地址空间的情况，所打开文件的列表和所使用的IO信息。
* 处理机相关信息：也称CPU上下文，**主要指CPU中各寄存器的值**。当进程处于执行状态时，CPU的许多信息都在寄存器中。当进程被切换时，CPU状态信息必须保存在响应的PCB中，以便在进程重新执行时，能从断点处继续执行。

在同一个系统中为了管理和调度进程 ，需要将PCB用适当的方法组织起来。常用的组织方式有链接方式和索引方式两种。

* **链接方式**将同一状态的PCB链接成一个队列，不同状态对应不同的队列。
* **索引方式**将同一状态的金成功组织在一个索引表中，索引表的表项指向相应的PCB。

#### 程序段

**程序段是能被进程调度到CPU执行的程序代码段。**程序可被多个进程共享，即多个进程可以运行同一个程序。

#### 数据段

进程的数据段可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。

### 2.1.3 进程的状态与转换

* 运行态：进程在CPU上运行
* 就绪态：进程已经获得了除CPU所有资源，等待CPU
* 阻塞态：又称等待态。进程正在等待某一事件而暂停运行。系统通常将处于阻塞态的进程也排成一个队列，根据阻塞原因不同，设置多个阻塞队列。
* 创建态：进程正在被创建，尚未转到就绪态。创建进程需要多个步骤：申请空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须得资源；最后将进程转入就绪态并插入就绪队列。
* 终止态：进程正在从系统中消失，系统首先将进程设置为终止态，然后进一步处理资源释放和回收等工作。

**就绪态和阻塞态的区别**：就绪态是只缺少CPU，有了CPU立刻运行。而阻塞态是指进程需要其他资源CPU或等待某一事件。

![image-20240624145852989](./pic/image-20240624145852989.png)

### 2.1.4 进程控制

**进程控制**的主要功能是**对系统中的所有进程实施有效的管理**。在操作系统中，一般将进程控制用的程序称为**原语**，原语的特点是执行期间不可以被中断，它是不可分割的基本单位。

#### 进程创建

允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程撤销时，应当从父进程那里获得的资源还回去；当父进程撤销时通常也会撤销所有的子进程。

在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。

创建新进程的过程如下（创建原语）：

* 为新进程分配一个唯一的进程标识号，并申请空白的PCB。若PCB请求失败则进程创建失败。
* 为进程分配其运行所需的资源。这些资源从操作系统或者父进程获得。如果资源不足（如内存），则**并不是创建失败，而是处于创建态**，等待内存资源。
* 初始化PCB，主要包括初始化标志信息，初始化CPU信息和初始化CPU控制信息，以及设置进程的优先级。
* 若进程就绪队列能接纳新进程，则将新进程插入就绪队列，等待被调度执行。

#### 进程终止

引起进程终止的事件主要有：

① 正常结束，表示进程的任务已经完成并准备退出运行

② 异常结束，表示进程在运行时，发生了某种异常事件

③ 外界干预

终止进程的过程（终止原语）：

* 根据被终止进程的标识符，检索出该进程的PCB，从中读取该进程的状态
* 若被终止进程处于运行状态，立即终止该进程的执行，将CPU资源分配给其他进程
* 若该进程还有子孙进程，则通常需将所有子孙进程终止
* 将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统
* 将该PCB从所在队列（链表）中删除

#### 进程的阻塞和唤醒

**正在执行的进程**由于期待某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新任务可做等，进程便通过调用**阻塞原语(Block)**，使自己由运行态变为阻塞态。**阻塞态是一种主动行为。**

阻塞原语的执行如下：

* 找到将要被阻塞进程的标识号PID对应的PCB
* 若该进程为运行态，则保护其现场将其状态转为阻塞态，停止运行
* 将该PCB插入**相应事件的等待队列**，将CPU资源调度给其他就绪进程

唤醒原语的执行如下：

* 在该事件的等待对垒中找到相应进程的PCB
* 将其从等待队列中移出，并置其状态为就绪态
* 将该PCB插入**就绪队列**，等待调度程序调度

等待和唤醒原语必须成对使用。

### 2.1.5 进程的通信

进程通信是指进程之间的信息交换。PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通信方式。

进程是分配系统资源的单位，因此各进程拥有的内存地址空间相互独立。

#### 共享存储

![image-20240624154015447](./pic/image-20240624154015447.png)

共享存储分为两种：低级方式的共享是基于**数据结构的共享**；高级方式的共享是基于**存储区的共享**。

操作系统只负责为通信进程提供可贡献使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。

#### 消息传递

若通信的进程之间不存在可直接访问的共享空间，则必须利用操作系统提供的消息传递方法实现进程通信。进程间的数据交换以**格式化的信息**为单位。进程通过操作系统提供的“发送消息/接收消息”两个**原语**进行数据交换。

* **直接通信方式。**发送进程直接将消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上，接收进程从消息缓冲队列中取得消息。
* **间接通信方式。**发送进程将进程发送到某个中间实体，接收进程从中间实体取得消息。这种中间实体称为**信箱**。

#### 管道通信

管道是一个特殊的**共享文件**。管道通信允许两个进程按生产者-消费者方式进行通信，只要管道不满，写进程就能向管道的一端写入数据；不空则可读。

* 管道只能采用**半双工通信**。如果要双向传输则需要设置两个管道。
* 各进程要**互斥**地访问管道
* 当管道写满时，写进程将阻塞；当管道读空时，读进程阻塞。
* 一个管道允许多个写进程，一个读进程。

![image-20240624161225232](./pic/image-20240624161225232.png)

### 2.1.6 线程和多线程模型

#### 线程的基本概念

引入进程的目的是更好地使多道程序并发执行，提高**资源利用率和系统吞吐量**；引入线程的目的是**减小程序在并发执行时所付出的时空开销**，提高操作系统的**并发性能**。

线程是轻量级进程，是一个基本的CPU执行单元，也是程序执行流的最小单元。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，**线程自己不拥有系统资源**，只拥有一点在运行中必不可少的资源，**但它可与同属一个进程的其他线程共享所拥有的全部资源。**

一个线程可以**创建和撤销另一个线程**，**同一进程中的多个线程之间可以并发执行**。由于线程之间的相互制约，致使线程在运行中呈现出**间断性**。

进程只作为除CPU外的系统资源的分配单元，而线程则作为CPU的分配单元。

#### 线程与进程的比较

* 调度：线程是独立调度的基本单位，线程的切换远低于进程。同一进程中切换线程不会引发进程切换，而不同进程的不同线程的切换会引发。
* 并发性：进程之间可以并发执行，一个进程中的多个线程仍然可以并发执行，不同进程中的线程也可以并发执行，而使操作系统具有更好的并发性。
* 拥有资源：进程是系统中拥有资源的基本单位，而线程不拥有资源
* 独立性：每个进程都拥有**独立的地址空间和资源**，除了共享全局变量，不允许其他进程访问。**某个进程中的线程对其他进程不可见**。**同一进程中的不同线程**是为了提高并发性及进行相互之间的合作而创建的，他们**共享进程的地址空间和资源。**

* 系统开销：在创建或撤销进程时，系统都要位置分配或回收进程控制块PCB及其他资源，如内存空间、IO设备等。明显大于线程的创建和撤销。类似进程切换时。
* 支持多处理器系统。对于传统单线程进程，不管有多少个CPU，进程只能运行在一个CPU上。对于多线程进程，可将进程中的多个线程分配到多个CPU上执行。

#### 线程的属性

进程的执行状态实际上指该进程中的线程正在执行，线程的属性如下：

* 线程是一个轻型实体，不拥有系统资源。**每个线程都应有一个唯一的标识符和一个线程控制块**，线程控制块记录线程执行的寄存器和栈等现场状态。
* 不同的线程可以执行相同的程序，**即同一个服务程序被不同的用户调用时，操作系统将它们创建成不同的线程。**
* 同一个进程中各个线程共享该进程拥有的资源
* 线程是CPU的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中，各线程可交替的暂用CPU；在多CPU的计算机系统中，各线程可同时占不同的CPU，若各个CPU同时为一个进程内的各线程服务，则可缩短进程的处理时间。
* 线程的生命周期有阻塞态、就绪态和运行态。

线程的提出有利于提高**并发性**：线程的切换可能不涉及进程的切换，平均而言每次切换的开销变小，能让更多的线程参与开发，不会影响到响应时间等问题。

#### 线程的状态与转换

* 执行态
* 阻塞态
* 就绪态

与进程一致。

#### 线程的组织与控制

1. 线程控制块TCB，用于记录控制和管理线程的信息。
   * 线程标识符
   * 一组寄存器
   * 线程运行状态
   * 优先级
   * 线程专有存储区：线程切换时用于保护现场
   * 堆栈指针：用于过程调用时保存局部变量及返回地址等
2. 线程的创建：用户程序启动时，通常仅有一个称为**初始化线程**正在执行，主要功能是用于创建新线程。在创建新线程时，需要利用一个**线程创建函数**，并提供相应的参数，如指向线程主程序的**入口指针、堆栈的大小、线程优先级等**。线程创建函数执行完后，将**返回一个线程标识符**。
3. 线程的终止：当一个线程完成自己的任务后，或线程在运行中出现异常而要被强制终止时，由**终止线程**调用相应的函数执行终止操作。但是有些线程(主要是**系统线程**)一旦被建立，便一直运行而不会被终止。通常，线程被终止后并**不立即释放它所占有的资源**，只有当进程中的其他线程执行了**分离函数**后，被终止线程才与资源分离，此时的资源才能被其他线程利用。**被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。**

#### 线程的实现方式

线程的实现可分为两类：用户级线程ULT和内核级线程KLT。内核级线程又称内核支持的线程。

1. 用户级线程：能从用户视角看到的线程。有关线程管理的所有工作都由应用程序在用户空间内完成，无需操作系统干预，**内核意识不到线程的存在**。

![image-20240624232934153](./pic/image-20240624232934153.png)

2. 内核级线程：能从操作系统视角看到的线程。

![image-20240624232957660](./pic/image-20240624232957660.png)

3. 组合方式

<img src="./pic/image-20240624233439535.png" alt="image-20240624233439535" style="zoom: 50%;" />

#### 多线程模型

在同时支持用户级线程和内核级线程的系统中，由于用户级线程链接方式不同，从而形成了下面三种不同的多线程模型。

1. 多对一模型：将多个用户级线程映射到一个内核级线程。
   * 优点：线程管理是在用户空间进行的，无需切换到核心态,效率比较高。
   * 缺点：一个线程在访问内核时发生阻塞则整个进程会被阻塞；只有一个线程能够访问内核，多个线程不能同时在多个CPU上运行
2. 一对一模型：每个进程有与用户级线程同等数量的内核级线程，线程切换由内核完成，需要切换到核心态。
   * 优点：一个线程阻塞后另一个线程允许运行，并发能力强
   * 缺点：每创建一个用户级线程需要创建一个内核级线程，开销较大
3. 多对多模型：用户线程数≥内核线程数

![image-20240624234119281](./pic/image-20240624234119281.png)

## 2.2 CPU 调度

### 2.2.1 调度的概念

CPU调度是多道程序操作系统的基础，是操作系统设计的核心问题。

#### 调度的层次

一个作业从提交到完成，需要经历以下三级调度

* 高级调度（作业调度）：作业调度是内存与辅存之间的调度。每个作业只调入一次、调出多次。多道批处理系统大多配有作业调度，而其他系统中不需要配置作业调度。
* 中级调度（内存调度）：中级

![image-20240624234458201](./pic/image-20240624234458201.png)
